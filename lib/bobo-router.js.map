{"version":3,"file":"bobo-router.js","sources":["../src/context.ts","../src/useLocation.ts","../src/matcher.ts","../src/tools.ts","../src/index.ts","../src/helper.ts","../src/index.ts"],"sourcesContent":["import { createContext } from 'react'\n\nexport type isMatch = boolean\nexport type params = {[key:string]:any}\nexport type matchFn = (pattern:string | RegExp,path:string) => [isMatch,params]\n\nexport interface store {\n    v:{\n        base:string\n        leaveGuardMap:{[path:string]:Function}\n        enterGuardMap:{[path:string]:Function}\n        prevPath:string\n        matcher:matchFn\n    }, \n    [customData:string]:any\n}\n\nexport const RouterCtx = createContext<store>({} as store)","import { useEffect,useState,useCallback,useRef,useContext } from 'react'\nimport { RouterCtx,store } from './context'\n\ndeclare namespace history {\n    function pushState(...p:any[]) : void\n    function replaceState(...p:any[]) : void\n    function popState(...p:any[]): void\n}\ntype navigate = (url:string,type ?: \"replace\" | \"to\") => void\n\nconst NOOP = () => {}\nlet INIT_PATCH_HISTORY_EVENT = 0\nconst useLocation = ({ base = \"\" } = {}):[string,navigate] => {\n    // only update component\n    const [path,update] = useState<string>(getCurrentPathname(base)) \n    const prevPath = useRef(path)\n    const globalRef = useRef<store['v']>(useContext(RouterCtx).v as any as store['v'])\n   \n    useEffect(() => {\n        const checkUpdate = () => {\n            let curPath = getCurrentPathname(base)\n            // globalRef.current.prevPath = prevPath.current\n            prevPath.current !== curPath && update((prevPath.current = curPath))\n        }\n        INIT_PATCH_HISTORY_EVENT || (INIT_PATCH_HISTORY_EVENT = 1,patchHistoryEvent(globalRef.current))\n        \n        const subscribeEvent = ['replaceState','pushState','popState']\n        // subscribe dep. wait emit...\n        subscribeEvent.forEach((event) => {\n            addEventListener(event,checkUpdate)\n        })\n\n        // checkUpdate()\n        return () => {\n            subscribeEvent.forEach((event) => {\n                removeEventListener(event,checkUpdate)\n            })\n        }\n    },[base])\n\n    const navigate:navigate = useCallback((url:string,type:\"replace\" | \"to\" = \"to\") => {\n        history[type == \"replace\" ? \"replaceState\" : \"pushState\"](0,'0',base + url,path)\n    },[])\n\n    return [path,navigate]\n}  \n\nfunction patchHistoryEvent(globalRef:store['v']) {\n    ;['replaceState','pushState'].forEach((event) => {\n        const ORIGINAL_EVENT = history[event]\n        history[event] = function(state:any,title:string,to:string,path:string) {\n            // leave guard: when false refuse navigate\n            let _next = false\n            if(to) {\n                const guardKey1 = JSON.stringify({ from: path,to }),\n                    guardKey2 = JSON.stringify({from: path, to: '*'})\n                let beforeLeaveGuard = to !== path && ( globalRef.leaveGuardMap[guardKey1] || globalRef.leaveGuardMap[guardKey2])  \n                \n                if(!beforeLeaveGuard) {\n                    // fuzzy match for params case \n                    // eg: /url/:id\n                    const matched = fuzzyMatchGuard(globalRef,to,path)\n                    matched && (beforeLeaveGuard = globalRef.leaveGuardMap[matched[0]])\n\n                    if(!beforeLeaveGuard) _next = true\n                }\n                if(beforeLeaveGuard) {\n                    beforeLeaveGuard(() => _next = true)\n                }\n            }\n\n            if(!_next) return null\n            const result = ORIGINAL_EVENT.apply(this,[state,title,to])\n            const subscribeEvent = new CustomEvent(event,{ detail: { to,path } })\n            dispatchEvent(subscribeEvent)\n          \n            return result\n        }\n\n        window.onpopstate = () => {\n            const from = globalRef.prevPath,\n                to = location.pathname\n            const guardKey1 = JSON.stringify({ from, to }),\n                guardKey2 = JSON.stringify({from, to: '*'})\n            let beforeLeaveGuards = from !== to && ( globalRef.leaveGuardMap[guardKey1] || globalRef.leaveGuardMap[guardKey2]) \n            // browser back action not refuse\n            beforeLeaveGuards && beforeLeaveGuards(NOOP)\n            \n            const popEvent = new CustomEvent('popState')\n            dispatchEvent(popEvent)\n        }\n        \n    })\n} \n\nfunction getCurrentPathname(base,pathname = location.pathname) {\n    // from basepath\n    return !pathname.indexOf(base) ? pathname.slice(base.length) || '/' : pathname\n}\n\nfunction fuzzyMatchGuard(globalRef:store['v'],to:string,from:string = '*', leaveGuardMap:string = \"leaveGuardMap\"):[string,any[]]{\n    const matcher = globalRef.matcher\n    const registeredGuardKeys = Object.keys(leaveGuardMap === 'leaveGuardMap' ? globalRef.leaveGuardMap : globalRef.enterGuardMap)\n\n    let params = null\n    const matched = registeredGuardKeys.find((guardGroupStr) => {\n        const guardGroup = JSON.parse(guardGroupStr)\n        if(guardGroup['from'] == from) {\n            let result\n            if((result = matcher(guardGroup['to'],to))[0]) {\n                params = result[1]\n                return true\n            } \n        }\n    })\n    return [matched,params]\n}\n\nexport {\n    fuzzyMatchGuard,\n    navigate,\n    useLocation\n}","// eslint-disable-next-line\nexport default function makeMatcher(makeRegexpFn = pathToRegexp) {\n    let cache = {}\n  \n    // obtains a cached regexp version of the pattern\n    const getRegexp = pattern =>\n        (cache[pattern]) || (cache[pattern] = makeRegexpFn(pattern))\n  \n    return (pattern, path) => {\n        const { regexp, keys } = getRegexp(pattern || \"\")\n        const out = regexp.exec(path)\n  \n        if (!out) return [false, null]\n  \n        // formats an object with matched params\n        const params = keys.reduce((params, key, i) => {\n            params[key.name] = out[i + 1]\n            return params\n        }, {})\n  \n        return [true, params]\n    }\n}\n  \nconst escapeRx = str => str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\")\n  \nconst rxForSegment = (repeat, optional, prefix) => {\n    let capture = repeat ? \"((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*)\" : \"([^\\\\/]+?)\"\n    if (optional && prefix) capture = \"(?:\\\\/\" + capture + \")\"\n    return capture + (optional ? \"?\" : \"\")\n}\n  \nconst pathToRegexp = pattern => {\n    const groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g\n  \n    let match = null,\n        lastIndex = 0,\n        keys = [],\n        result = \"\"\n  \n    while ((match = groupRx.exec(pattern)) !== null) {\n        const [_, segment, mod] = match\n  \n        const repeat = mod === \"+\" || mod === \"*\"\n        const optional = mod === \"?\" || mod === \"*\"\n        const prefix = optional && pattern[match.index - 1] === \"/\" ? 1 : 0\n  \n        const prev = pattern.substring(lastIndex, match.index - prefix)\n  \n        keys.push({ name: segment })\n        lastIndex = groupRx.lastIndex\n  \n        result += escapeRx(prev) + rxForSegment(repeat, optional, prefix)\n    }\n  \n    result += escapeRx(pattern.substring(lastIndex))\n    return { keys, regexp: new RegExp(\"^\" + result + \"(?:\\\\/)?$\", \"i\") }\n}\n","import { useRef } from 'react'\n\nexport const useActionEffect = (action:Function,deps:unknown[]) => {\n    const depRef = useRef<unknown[]>()\n    if(isEqual(depRef.current,deps)) return\n    \n    action()\n    depRef.current = deps\n}\n\nfunction is(x:unknown, y:unknown) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n  \nfunction isEqual(old,cur) {\n    if(is(old,cur)) return true\n    if(typeof old !== 'object' || typeof cur !== 'object') return false\n\n    const oldKeys = Object.keys(old)\n    const curKeys = Object.keys(cur)\n    \n    if(oldKeys.length !== curKeys.length) return false\n    // plain object or array\n    curKeys.forEach((key) => {\n        if(cur[key] !== old[key]) return false\n    })\n    return true\n}","import { useLocation as useLocationHook,navigate,fuzzyMatchGuard }  from './useLocation'\nimport makeMatcher from \"./matcher\"\nimport { useActionEffect } from './tools'\n\nimport {\n    useRef,\n    useLayoutEffect,\n    useEffect,\n    useContext,\n    useCallback,\n    isValidElement,\n    cloneElement,\n    createElement as h,\n    Suspense,\n    lazy,\n} from \"react\"\n\nimport { RouterCtx,store,isMatch,params,matchFn } from './context'\nexport { getParams } from './helper'\n\ninterface ILeaveGuard {\n    (navigate:Function, next:Function):void\n}\n\ninterface IEnterGuard {\n    (params: Object, navigate:Function, next: Function):void\n}\n\ntype RouteProps = {\n    path:string,\n    match ?: matchFn\n    enterGuard ?: EnterRouteGuard,\n    updateGuard ?: UpdateRouteGuard,\n    component ?: React.FC | React.ComponentClass,\n    exact ?: boolean,\n    isAlive ?: boolean\n} \n\ntype updateGuardStruct = {\n    timer:number;\n    path:string;\n    prevParams:params;\n}\n\ntype guardTypes = 'beforeLeave' | 'beforeUpdate' | 'beforeEnter'\n\ninterface RouterGuard {\n    path ?: string,\n    to:string,\n    resolve:(navigate:navigate,next:Function) => void,\n    type:\"beforeLeave\" | \"beforeEnter\"\n} \n\ninterface EnterRouteGuard {\n    (params:any,navigate:navigate,next:Function) : void,\n}\n\ninterface UpdateRouteGuard {\n    (beforeParams:params,currentParams:params,navigate:Function,next:Function):void\n}\n\nenum ExecuteGuardType {\n    None,\n    Update,\n    // If not in exact mode. However should execute update instead enter\n    Update_UnResolve,\n    Enter,\n}\n\nconst buildRouter = ({\n    base = \"\",\n    matcher = makeMatcher() as any,\n    enterGuardMap = {},\n    leaveGuardMap = {},\n    prevPath = \"\"\n}:store['v'] = {} as store['v']) => ({ base, matcher,leaveGuardMap,prevPath, enterGuardMap })\n\nexport const useRouter = () => {\n    const globalRef = useContext(RouterCtx)\n    return globalRef.v || (globalRef.v = buildRouter())\n}\n\nexport const useLocation = () => {\n    const router = useRouter()\n    return useLocationHook(router)\n}\n\nexport const useRoute = (pattern:RegExp | string):[[isMatch,params],string,(type:\"replace\" | \"to\",url:string) => void] => {\n    const [path,navigate] = useLocation()\n    return [useRouter().matcher(pattern, path),path,navigate]\n}\n\nexport const useNestRoute = (pattern:RegExp | string,prevMatchObject?:updateGuardStruct):[[isMatch,params],string,(type:\"replace\" | \"to\",url:string) => void] => {\n    const [path,navigate] = useLocation()\n    const matcher = useRouter().matcher\n\n    const match_paths = path.split('/')\n    let useRouteMatch:[isMatch,params] = [false,{}]\n\n    // avoid '/' Component show in any router\n    for(let i = 1,base = \"/\";i < match_paths.length;i++) {\n        let curPath = base + match_paths[i]\n        const result = matcher(pattern,curPath)\n        if(result[0]) {\n            if(prevMatchObject) {\n                if(prevMatchObject!.path !== curPath) {\n                    prevMatchObject.path = curPath\n                    prevMatchObject.timer++\n                    prevMatchObject.prevParams = result[1]\n                }\n            } \n            useRouteMatch = result\n            break\n        }\n        base += match_paths[i] + '/'\n    }\n    useRouteMatch[0] || prevMatchObject && (prevMatchObject.timer = 0,prevMatchObject.prevParams = {})\n    return [useRouteMatch,path,navigate]\n}\n\nexport const Router = props => {\n    const ref = useRef<null | store>(null)\n\n    // only in first render to call buildRouter\n    const value = ref.current || (ref.current = { v: buildRouter(props) })\n\n    return h(RouterCtx.Provider, {\n        value: value,\n        children: props.children\n    })\n}\n\nexport const Route:React.FC<RouteProps> = ({ path, match, component, children, enterGuard,updateGuard,exact = false,isAlive }) => {\n    const updateParamsRef = useRef<updateGuardStruct>({ path: \"\",timer: 0,prevParams: {} })\n    const prevParams = updateParamsRef.current.prevParams\n    const [useRouteMatch,basePath,navigate] = !exact ? useNestRoute(path,updateParamsRef.current) : useRoute(path)\n    const globalCtx = useRouter()\n\n    useActionEffect(() => {\n        if(!enterGuard) return\n        let guardGroup = JSON.stringify({ from: '*',to: path })\n        globalCtx.enterGuardMap[guardGroup] = (params,next) => enterGuard(params,navigate,next)\n    },[enterGuard])\n    const [matches, params] = match && match(path,basePath) || useRouteMatch\n\n    if(!matches) {\n        if(!isAlive) return null\n        else return renderChild({ display: 'none' })\n    }\n\n    // beforeEnter | beforeUpdate guard\n    globalCtx.prevPath = basePath\n    // judge execute RouteGuard Type\n    // Type: Update | Enter \n    // emit UpdateGuard\n    let _next = false\n    const next = () => _next = true\n    let executeGuardType = ExecuteGuardType.Enter\n    if(updateParamsRef.current.timer > 1) {\n        // only emit UpdateGuard in unExact Mode \n        if(!exact) {\n            if(updateGuard) {\n                updateGuard(prevParams,updateParamsRef.current.prevParams,navigate,next)\n            } else next()\n            executeGuardType = ExecuteGuardType.Update\n        }\n        else executeGuardType = ExecuteGuardType.Update_UnResolve\n    }\n\n    if(executeGuardType == ExecuteGuardType.Enter) {\n        const from = '*'\n        const guardGroup = JSON.stringify({ from: from,to: basePath })\n        const executeGuard = globalCtx.enterGuardMap[guardGroup]  \n        \n        if(executeGuard) {\n            executeGuard(null,next) \n        } else {\n            const matched = fuzzyMatchGuard(globalCtx,basePath, '*', 'enterGuardMap')\n            if(matched[0]) {\n                const fuzzyExecuteGuard = globalCtx.enterGuardMap[matched[0]]\n                fuzzyExecuteGuard(matched[1],next)\n            }\n            else next()\n        }\n    }\n\n    if(!_next) return null\n    return renderChild()\n\n    function renderChild(extraProps ?: object) {\n        if (component) return h(component, { params,...extraProps } as any)\n\n        // support render prop or plain children\n        return typeof children === \"function\" ? cloneElement(children(params),extraProps) : cloneElement(children as any,extraProps)\n    }\n}\n\nexport const useLeaveGuard = (props:Exclude<RouterGuard, 'type'>) => {\n    const [curPath,navigate] = useLocationHook()\n    const { path = curPath,resolve,to } = props\n    const globalRef = useContext(RouterCtx)\n    \n    useEffect(() => {  \n        let realPath = path\n        const currentGuardFlagGroup = JSON.stringify({ from: realPath,to })\n        globalRef.v.leaveGuardMap[currentGuardFlagGroup] = next => resolve(navigate,next)\n    },[path,resolve,to])\n}\n\nexport const connectGuard = (type:Exclude<guardTypes,'beforeUpdate'>,resolve:ILeaveGuard | IEnterGuard,from:string,to?:string) => (Component:React.FC):React.FC => {\n    if(type === 'beforeEnter' || !to) {\n        to = '*'\n    }\n\n    return (props) => {\n        const { children,...others } = props\n        const matcher = useRouter().matcher\n        const globalRef = useContext(RouterCtx)\n        const { prevPath } = globalRef.v\n        const [curPath,navigate] = useLocationHook()\n\n        let nextRender = 0\n        const next = () => {\n            nextRender = 1\n        }\n\n        if(type === 'beforeEnter' ) {\n            if(from === '*' || matcher(from,prevPath)[0]) {\n                (resolve as IEnterGuard)(prevPath,navigate,next)\n            }\n        } else if(type === 'beforeLeave') {\n            const resolve1:ILeaveGuard = resolve as ILeaveGuard\n            useLeaveGuard({\n                resolve: resolve1,\n                to,\n                type: 'beforeLeave'\n            })\n            nextRender = 1\n        }\n\n        if(nextRender) return h(Component,others,children)\n        return h('div')\n    }\n}\n\nexport const Link = props => {\n    const [, navigate] = useLocation()\n    const { base } = useRouter()\n\n    const href = props.href || props.to\n    const { children, onClick } = props\n\n    const handleClick = useCallback(\n        event => {\n            if (\n                event.ctrlKey ||\n                event.metaKey ||\n                event.altKey ||\n                event.shiftKey ||\n                event.button !== 0\n            )\n                return\n\n            event.preventDefault()\n            navigate(href)\n            onClick && onClick(event)\n        },\n        [href, onClick, navigate]\n    )\n\n    // default render 'a' component\n    const extraProps = { href: base + href, onClick: handleClick, to: null }\n    const jsx = isValidElement(children) ? children : h(\"a\", props)\n\n    return cloneElement(jsx, extraProps)\n}\n\nexport const Switch = ({ children, location }) => {\n    const { matcher } = useRouter()\n    const [originalLocation] = useLocation()\n\n    children = Array.isArray(children) ? children : [children]\n\n    for (const element of children) {\n        let match:[boolean,params]\n\n        if (\n            isValidElement(element) &&\n            \n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = element.props['path']\n          ? matcher(element.props['path'], location || originalLocation)\n          : [false, {}]\n      )[0]\n        )\n            return cloneElement(element, { match,path: element.props['path'] } as any)\n    }\n\n    // eslint-disable-next-line\n    console.warn(`\n        Switch component has no suitable render element;\n        please check path prop\n    `)\n    return null\n}\n\nexport const Redirect = props => {\n    const [, push] = useLocation()\n    useLayoutEffect(() => {\n        // layout has finished \n        // replace url to new \n        push(\"replace\" ,props.href || props.to)\n\n    // we pass an empty array of dependecies to ensure that\n    // we only run the effect once after initial render\n    }, []) \n\n    return null\n}\n\n\nexport const Lazy:React.FC<{loading:React.ReactNode,component:() => Promise<{default:React.ComponentType}>}> = ({ loading,component }) => {\n    const RC = lazy(component) \n    return h(Suspense,{ fallback: loading },h(RC))\n}\n    \n\nexport default useRoute","import { useRoute,useNestRoute } from './index'\n\nexport const getParams = (isExact:boolean,pattern:RegExp | string,...params: string[]) => {\n    const current_params = isExact ? useRoute(pattern)[0][1] : useNestRoute(pattern)[0][1]\n    const result = {}\n    for(let param of params) {\n        result[param] = current_params[param]\n    }\n    return result\n}","import { useLocation as useLocationHook,navigate,fuzzyMatchGuard }  from './useLocation'\nimport makeMatcher from \"./matcher\"\nimport { useActionEffect } from './tools'\n\nimport {\n    useRef,\n    useLayoutEffect,\n    useEffect,\n    useContext,\n    useCallback,\n    isValidElement,\n    cloneElement,\n    createElement as h,\n    Suspense,\n    lazy,\n} from \"react\"\n\nimport { RouterCtx,store,isMatch,params,matchFn } from './context'\nexport { getParams } from './helper'\n\ninterface ILeaveGuard {\n    (navigate:Function, next:Function):void\n}\n\ninterface IEnterGuard {\n    (params: Object, navigate:Function, next: Function):void\n}\n\ntype RouteProps = {\n    path:string,\n    match ?: matchFn\n    enterGuard ?: EnterRouteGuard,\n    updateGuard ?: UpdateRouteGuard,\n    component ?: React.FC | React.ComponentClass,\n    exact ?: boolean,\n    isAlive ?: boolean\n} \n\ntype updateGuardStruct = {\n    timer:number;\n    path:string;\n    prevParams:params;\n}\n\ntype guardTypes = 'beforeLeave' | 'beforeUpdate' | 'beforeEnter'\n\ninterface RouterGuard {\n    path ?: string,\n    to:string,\n    resolve:(navigate:navigate,next:Function) => void,\n    type:\"beforeLeave\" | \"beforeEnter\"\n} \n\ninterface EnterRouteGuard {\n    (params:any,navigate:navigate,next:Function) : void,\n}\n\ninterface UpdateRouteGuard {\n    (beforeParams:params,currentParams:params,navigate:Function,next:Function):void\n}\n\nenum ExecuteGuardType {\n    None,\n    Update,\n    // If not in exact mode. However should execute update instead enter\n    Update_UnResolve,\n    Enter,\n}\n\nconst buildRouter = ({\n    base = \"\",\n    matcher = makeMatcher() as any,\n    enterGuardMap = {},\n    leaveGuardMap = {},\n    prevPath = \"\"\n}:store['v'] = {} as store['v']) => ({ base, matcher,leaveGuardMap,prevPath, enterGuardMap })\n\nexport const useRouter = () => {\n    const globalRef = useContext(RouterCtx)\n    return globalRef.v || (globalRef.v = buildRouter())\n}\n\nexport const useLocation = () => {\n    const router = useRouter()\n    return useLocationHook(router)\n}\n\nexport const useRoute = (pattern:RegExp | string):[[isMatch,params],string,(type:\"replace\" | \"to\",url:string) => void] => {\n    const [path,navigate] = useLocation()\n    return [useRouter().matcher(pattern, path),path,navigate]\n}\n\nexport const useNestRoute = (pattern:RegExp | string,prevMatchObject?:updateGuardStruct):[[isMatch,params],string,(type:\"replace\" | \"to\",url:string) => void] => {\n    const [path,navigate] = useLocation()\n    const matcher = useRouter().matcher\n\n    const match_paths = path.split('/')\n    let useRouteMatch:[isMatch,params] = [false,{}]\n\n    // avoid '/' Component show in any router\n    for(let i = 1,base = \"/\";i < match_paths.length;i++) {\n        let curPath = base + match_paths[i]\n        const result = matcher(pattern,curPath)\n        if(result[0]) {\n            if(prevMatchObject) {\n                if(prevMatchObject!.path !== curPath) {\n                    prevMatchObject.path = curPath\n                    prevMatchObject.timer++\n                    prevMatchObject.prevParams = result[1]\n                }\n            } \n            useRouteMatch = result\n            break\n        }\n        base += match_paths[i] + '/'\n    }\n    useRouteMatch[0] || prevMatchObject && (prevMatchObject.timer = 0,prevMatchObject.prevParams = {})\n    return [useRouteMatch,path,navigate]\n}\n\nexport const Router = props => {\n    const ref = useRef<null | store>(null)\n\n    // only in first render to call buildRouter\n    const value = ref.current || (ref.current = { v: buildRouter(props) })\n\n    return h(RouterCtx.Provider, {\n        value: value,\n        children: props.children\n    })\n}\n\nexport const Route:React.FC<RouteProps> = ({ path, match, component, children, enterGuard,updateGuard,exact = false,isAlive }) => {\n    const updateParamsRef = useRef<updateGuardStruct>({ path: \"\",timer: 0,prevParams: {} })\n    const prevParams = updateParamsRef.current.prevParams\n    const [useRouteMatch,basePath,navigate] = !exact ? useNestRoute(path,updateParamsRef.current) : useRoute(path)\n    const globalCtx = useRouter()\n\n    useActionEffect(() => {\n        if(!enterGuard) return\n        let guardGroup = JSON.stringify({ from: '*',to: path })\n        globalCtx.enterGuardMap[guardGroup] = (params,next) => enterGuard(params,navigate,next)\n    },[enterGuard])\n    const [matches, params] = match && match(path,basePath) || useRouteMatch\n\n    if(!matches) {\n        if(!isAlive) return null\n        else return renderChild({ display: 'none' })\n    }\n\n    // beforeEnter | beforeUpdate guard\n    globalCtx.prevPath = basePath\n    // judge execute RouteGuard Type\n    // Type: Update | Enter \n    // emit UpdateGuard\n    let _next = false\n    const next = () => _next = true\n    let executeGuardType = ExecuteGuardType.Enter\n    if(updateParamsRef.current.timer > 1) {\n        // only emit UpdateGuard in unExact Mode \n        if(!exact) {\n            if(updateGuard) {\n                updateGuard(prevParams,updateParamsRef.current.prevParams,navigate,next)\n            } else next()\n            executeGuardType = ExecuteGuardType.Update\n        }\n        else executeGuardType = ExecuteGuardType.Update_UnResolve\n    }\n\n    if(executeGuardType == ExecuteGuardType.Enter) {\n        const from = '*'\n        const guardGroup = JSON.stringify({ from: from,to: basePath })\n        const executeGuard = globalCtx.enterGuardMap[guardGroup]  \n        \n        if(executeGuard) {\n            executeGuard(null,next) \n        } else {\n            const matched = fuzzyMatchGuard(globalCtx,basePath, '*', 'enterGuardMap')\n            if(matched[0]) {\n                const fuzzyExecuteGuard = globalCtx.enterGuardMap[matched[0]]\n                fuzzyExecuteGuard(matched[1],next)\n            }\n            else next()\n        }\n    }\n\n    if(!_next) return null\n    return renderChild()\n\n    function renderChild(extraProps ?: object) {\n        if (component) return h(component, { params,...extraProps } as any)\n\n        // support render prop or plain children\n        return typeof children === \"function\" ? cloneElement(children(params),extraProps) : cloneElement(children as any,extraProps)\n    }\n}\n\nexport const useLeaveGuard = (props:Exclude<RouterGuard, 'type'>) => {\n    const [curPath,navigate] = useLocationHook()\n    const { path = curPath,resolve,to } = props\n    const globalRef = useContext(RouterCtx)\n    \n    useEffect(() => {  \n        let realPath = path\n        const currentGuardFlagGroup = JSON.stringify({ from: realPath,to })\n        globalRef.v.leaveGuardMap[currentGuardFlagGroup] = next => resolve(navigate,next)\n    },[path,resolve,to])\n}\n\nexport const connectGuard = (type:Exclude<guardTypes,'beforeUpdate'>,resolve:ILeaveGuard | IEnterGuard,from:string,to?:string) => (Component:React.FC):React.FC => {\n    if(type === 'beforeEnter' || !to) {\n        to = '*'\n    }\n\n    return (props) => {\n        const { children,...others } = props\n        const matcher = useRouter().matcher\n        const globalRef = useContext(RouterCtx)\n        const { prevPath } = globalRef.v\n        const [curPath,navigate] = useLocationHook()\n\n        let nextRender = 0\n        const next = () => {\n            nextRender = 1\n        }\n\n        if(type === 'beforeEnter' ) {\n            if(from === '*' || matcher(from,prevPath)[0]) {\n                (resolve as IEnterGuard)(prevPath,navigate,next)\n            }\n        } else if(type === 'beforeLeave') {\n            const resolve1:ILeaveGuard = resolve as ILeaveGuard\n            useLeaveGuard({\n                resolve: resolve1,\n                to,\n                type: 'beforeLeave'\n            })\n            nextRender = 1\n        }\n\n        if(nextRender) return h(Component,others,children)\n        return h('div')\n    }\n}\n\nexport const Link = props => {\n    const [, navigate] = useLocation()\n    const { base } = useRouter()\n\n    const href = props.href || props.to\n    const { children, onClick } = props\n\n    const handleClick = useCallback(\n        event => {\n            if (\n                event.ctrlKey ||\n                event.metaKey ||\n                event.altKey ||\n                event.shiftKey ||\n                event.button !== 0\n            )\n                return\n\n            event.preventDefault()\n            navigate(href)\n            onClick && onClick(event)\n        },\n        [href, onClick, navigate]\n    )\n\n    // default render 'a' component\n    const extraProps = { href: base + href, onClick: handleClick, to: null }\n    const jsx = isValidElement(children) ? children : h(\"a\", props)\n\n    return cloneElement(jsx, extraProps)\n}\n\nexport const Switch = ({ children, location }) => {\n    const { matcher } = useRouter()\n    const [originalLocation] = useLocation()\n\n    children = Array.isArray(children) ? children : [children]\n\n    for (const element of children) {\n        let match:[boolean,params]\n\n        if (\n            isValidElement(element) &&\n            \n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = element.props['path']\n          ? matcher(element.props['path'], location || originalLocation)\n          : [false, {}]\n      )[0]\n        )\n            return cloneElement(element, { match,path: element.props['path'] } as any)\n    }\n\n    // eslint-disable-next-line\n    console.warn(`\n        Switch component has no suitable render element;\n        please check path prop\n    `)\n    return null\n}\n\nexport const Redirect = props => {\n    const [, push] = useLocation()\n    useLayoutEffect(() => {\n        // layout has finished \n        // replace url to new \n        push(\"replace\" ,props.href || props.to)\n\n    // we pass an empty array of dependecies to ensure that\n    // we only run the effect once after initial render\n    }, []) \n\n    return null\n}\n\n\nexport const Lazy:React.FC<{loading:React.ReactNode,component:() => Promise<{default:React.ComponentType}>}> = ({ loading,component }) => {\n    const RC = lazy(component) \n    return h(Suspense,{ fallback: loading },h(RC))\n}\n    \n\nexport default useRoute"],"names":["createContext","useState","useRef","useContext","useEffect","useCallback","useLocation","useLocationHook","ExecuteGuardType","buildRouter","useRouter","useRoute","useNestRoute","h","cloneElement","isValidElement","useLayoutEffect","lazy","Suspense"],"mappings":"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"}
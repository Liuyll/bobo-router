{"version":3,"file":"bobo-router.esm.js","sources":["../src/context.ts","../src/useLocation.ts","../src/matcher.ts","../src/tools.ts","../src/index.ts","../src/helper.ts","../src/index.ts"],"sourcesContent":["import { createContext } from 'react'\n\nexport type isMatch = boolean\nexport type params = {[key:string]:any}\nexport type matchFn = (pattern:string | RegExp,path:string) => [isMatch,params]\n\nexport interface store {\n    v:{\n        base:string,\n        guardMap:{[path:string]:Function},\n        prevPath:string,\n        matcher:matchFn,\n    }, \n    [customData:string]:any\n}\n\nexport const RouterCtx = createContext<store>({} as store)","import { useEffect,useState,useCallback,useRef,useContext } from 'react'\nimport { RouterCtx,store } from './context'\n\ndeclare namespace history {\n    function pushState(...p:any[]) : void\n    function replaceState(...p:any[]) : void\n}\n\nexport type navigate = (url:string,type ?: \"replace\" | \"to\") => void\n\nlet INIT_PATCH_HISTORY_EVENT = 0\nexport const useLocation = ({ base = \"\" } = {}):[string,navigate] => {\n    // only update component\n    const [path,update] = useState<string>(getCurrentPathname(base)) \n    const prevPath = useRef(path)\n    const globalRef = useRef<store['v']>(useContext(RouterCtx).v as any as store['v'])\n   \n    useEffect(() => {\n        const checkUpdate = () => {\n            let curPath = getCurrentPathname(base)\n            // globalRef.current.prevPath = prevPath.current\n            prevPath.current !== curPath && update((prevPath.current = curPath))\n        }\n        INIT_PATCH_HISTORY_EVENT || (INIT_PATCH_HISTORY_EVENT = 1,patchHistoryEvent(globalRef.current))\n        \n        const subscribeEvent = ['replaceState','pushState','popState']\n        subscribeEvent.forEach((event) => {\n            addEventListener(event,checkUpdate)\n        })\n\n        // checkUpdate()\n        return () => {\n            subscribeEvent.forEach((event) => {\n                removeEventListener(event,checkUpdate)\n            })\n        }\n    },[base])\n\n    const navigate:navigate = useCallback((url:string,type:\"replace\" | \"to\" = \"to\") => {\n        history[type == \"replace\" ? \"replaceState\" : \"pushState\"](0,'0',base + url,path)\n    },[])\n\n    return [path,navigate]\n}  \n\nfunction patchHistoryEvent(globalRef:store['v']) {\n    ;['replaceState','pushState'].forEach((event) => {\n        const ORIGINAL_EVENT = history[event]\n        history[event] = function(state:any,title:string,to:string,path:string) {\n            // route guard\n            let isNavigate = false\n            if(to) {\n                let beforeLeaveGuards = to !== path && globalRef.guardMap[JSON.stringify({ from: path,to })]   \n\n                // wait expose ... in component guard hooks\n                // const beforeUpdateGuards = to == path && globalRef.guardMap[JSON.stringify({ from: path,to })]\n                // const beforeEnterGuards = to !== path && globalRef.guardMap[JSON.stringify({ from: '*', to })]\n                \n                if(!beforeLeaveGuards) {\n                    // fuzzy match for params case \n                    // eg: /url/:id\n                    const matched = fuzzyMatchGuard(globalRef,to,path)\n                    matched && (beforeLeaveGuards = globalRef.guardMap[matched[0]])\n\n                    if(!beforeLeaveGuards) isNavigate = true\n                }\n                if(beforeLeaveGuards) {\n                    beforeLeaveGuards(() => isNavigate = true)\n                }\n\n            }\n\n            // one step: emit route guard\n            if(!isNavigate) return null\n\n            //two step: call histroy api to make location.pathname update\n            const result = ORIGINAL_EVENT.apply(this,[state,title,to])\n\n            // three step: call subscriber\n            const subscribe_event = new CustomEvent(event,{ detail: { to,path } })\n            dispatchEvent(subscribe_event)\n          \n            return result\n        }\n        \n    })\n} \n\nfunction getCurrentPathname(base,pathname = location.pathname) {\n    // from basepath\n    return !pathname.indexOf(base) ? pathname.slice(base.length) || '/' : pathname\n}\n\nexport function fuzzyMatchGuard(globalRef:store['v'],to:string,from:string = '*'):[string,any[]]{\n    const matcher = globalRef.matcher\n    const registeredGuardKeys = Object.keys(globalRef.guardMap)\n\n    let params = null\n    const matched = registeredGuardKeys.find((guardGroupStr) => {\n        const guardGroup = JSON.parse(guardGroupStr)\n        if(guardGroup['from'] == from) {\n            let result\n            if((result = matcher(guardGroup['to'],to))[0]) {\n                params = result[1]\n                return true\n            } \n        }\n    })\n    return [matched,params]\n}","// eslint-disable-next-line\nexport default function makeMatcher(makeRegexpFn = pathToRegexp) {\n    let cache = {}\n  \n    // obtains a cached regexp version of the pattern\n    const getRegexp = pattern =>\n        (cache[pattern]) || (cache[pattern] = makeRegexpFn(pattern))\n  \n    return (pattern, path) => {\n        const { regexp, keys } = getRegexp(pattern || \"\")\n        const out = regexp.exec(path)\n  \n        if (!out) return [false, null]\n  \n        // formats an object with matched params\n        const params = keys.reduce((params, key, i) => {\n            params[key.name] = out[i + 1]\n            return params\n        }, {})\n  \n        return [true, params]\n    }\n}\n  \nconst escapeRx = str => str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\")\n  \nconst rxForSegment = (repeat, optional, prefix) => {\n    let capture = repeat ? \"((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*)\" : \"([^\\\\/]+?)\"\n    if (optional && prefix) capture = \"(?:\\\\/\" + capture + \")\"\n    return capture + (optional ? \"?\" : \"\")\n}\n  \nconst pathToRegexp = pattern => {\n    const groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g\n  \n    let match = null,\n        lastIndex = 0,\n        keys = [],\n        result = \"\"\n  \n    while ((match = groupRx.exec(pattern)) !== null) {\n        const [_, segment, mod] = match\n  \n        const repeat = mod === \"+\" || mod === \"*\"\n        const optional = mod === \"?\" || mod === \"*\"\n        const prefix = optional && pattern[match.index - 1] === \"/\" ? 1 : 0\n  \n        const prev = pattern.substring(lastIndex, match.index - prefix)\n  \n        keys.push({ name: segment })\n        lastIndex = groupRx.lastIndex\n  \n        result += escapeRx(prev) + rxForSegment(repeat, optional, prefix)\n    }\n  \n    result += escapeRx(pattern.substring(lastIndex))\n    return { keys, regexp: new RegExp(\"^\" + result + \"(?:\\\\/)?$\", \"i\") }\n}\n","import { useRef } from 'react'\n\nexport const useActionEffect = (action:Function,deps:unknown[]) => {\n    const depRef = useRef<unknown[]>()\n    if(isEqual(depRef.current,deps)) return\n    \n    action()\n    depRef.current = deps\n}\n\nfunction is(x:unknown, y:unknown) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n  \nfunction isEqual(old,cur) {\n    if(is(old,cur)) return true\n    if(typeof old !== 'object' || typeof cur !== 'object') return false\n\n    const oldKeys = Object.keys(old)\n    const curKeys = Object.keys(cur)\n    \n    if(oldKeys.length !== curKeys.length) return false\n    // plain object or array\n    curKeys.forEach((key) => {\n        if(cur[key] !== old[key]) return false\n    })\n    return true\n}","import { useLocation as useLocationHook,navigate,fuzzyMatchGuard }  from './useLocation'\nimport makeMatcher from \"./matcher\"\nimport { useActionEffect } from './tools'\n\nimport {\n    useRef,\n    useLayoutEffect,\n    useEffect,\n    useContext,\n    useCallback,\n    isValidElement,\n    cloneElement,\n    createElement as h,\n    Suspense,\n    lazy,\n} from \"react\"\n\nimport { RouterCtx,store,isMatch,params,matchFn } from './context'\nexport { getParams } from './helper'\n/*\n * Hooks API: useRouter, useRoute and useLocation\n */\n\ntype RouteProps = {\n    path:string,\n    match ?: matchFn\n    enterGuard ?: EnterRouteGuard,\n    updateGuard ?: UpdateRouteGuard,\n    component ?: React.FC | React.ComponentClass,\n    exact ?: boolean,\n    isAlive ?: boolean\n} \n\ntype updateGuardStruct = {\n    timer:number;\n    path:string;\n    prevParams:params;\n}\n\ntype guardTypes = 'beforeLeave' | 'beforeUpdate' | 'beforeEnter'\n\ninterface RouterGuard {\n    path ?: string,\n    to:string,\n    resolve:(navigate:navigate,next:Function) => void,\n    type:\"beforeLeave\" | \"beforeEnter\"\n} \n\ninterface EnterRouteGuard {\n    (params:any,navigate:navigate,next:Function) : void,\n}\n\ninterface UpdateRouteGuard {\n    (beforeParams:params,currentParams:params,navigate:Function,next:Function):void\n}\nconst buildRouter = ({\n    base = \"\",\n    matcher = makeMatcher() as any,\n    guardMap = {},\n    prevPath = \"\"\n}:store['v'] = {} as store['v']) => ({ base, matcher,guardMap,prevPath })\n\nexport const useRouter = () => {\n    const globalRef = useContext(RouterCtx)\n\n    // either obtain the router from the outer context (provided by the\n    // `<Router /> component) or create an implicit one on demand.\n    return globalRef.v || (globalRef.v = buildRouter())\n}\n\nexport const useLocation = () => {\n    const router = useRouter()\n    return useLocationHook(router)\n}\n\nexport const useRoute = (pattern:RegExp | string):[[isMatch,params],string,(type:\"replace\" | \"to\",url:string) => void] => {\n    const [path,navigate] = useLocation()\n    return [useRouter().matcher(pattern, path),path,navigate]\n}\n\nexport const useNestRoute = (pattern:RegExp | string,prevMatchObject?:updateGuardStruct):[[isMatch,params],string,(type:\"replace\" | \"to\",url:string) => void] => {\n    const [path,navigate] = useLocation()\n    const matcher = useRouter().matcher\n\n    const match_paths = path.split('/')\n    let useRouteMatch:[isMatch,params] = [false,{}]\n\n    // avoid '/' Component show in any router\n    for(let i = 1,base = \"/\";i < match_paths.length;i++) {\n        let curPath = base + match_paths[i]\n        const result = matcher(pattern,curPath)\n        if(result[0]) {\n            if(prevMatchObject) {\n                if(prevMatchObject!.path !== curPath) {\n                    prevMatchObject.path = curPath\n                    prevMatchObject.timer++\n                    prevMatchObject.prevParams = result[1]\n                }\n            } \n            useRouteMatch = result\n            break\n        }\n        base += match_paths[i] + '/'\n    }\n    useRouteMatch[0] || prevMatchObject && (prevMatchObject.timer = 0,prevMatchObject.prevParams = {})\n    return [useRouteMatch,path,navigate]\n}\n\n/*\n * Router API: Router, Route, Link, Switch\n */\n\nexport const Router = props => {\n    const ref = useRef<null | store>(null)\n\n    // only in first render to call buildRouter\n    const value = ref.current || (ref.current = { v: buildRouter(props) })\n\n    return h(RouterCtx.Provider, {\n        value: value,\n        children: props.children\n    })\n}\n\nexport const Route:React.FC<RouteProps> = ({ path, match, component, children, enterGuard,updateGuard,exact = false,isAlive }) => {\n    const updateParamsRef = useRef<updateGuardStruct>({ path: \"\",timer: 0,prevParams: {} })\n    const prevParams = updateParamsRef.current.prevParams\n    const [useRouteMatch,basePath,navigate] = !exact ? useNestRoute(path,updateParamsRef.current) : useRoute(path)\n    const globalCtx = useRouter()\n\n    useActionEffect(() => {\n        if(!enterGuard) return\n        let guardGroup = JSON.stringify({ from: '*',to: path })\n        globalCtx.guardMap[guardGroup] = (params,next) => enterGuard(params,navigate,next)\n    },[enterGuard])\n    // `props.match` is present - Route is controlled by the Switch\n    const [matches, params] = match && match(path,basePath) || useRouteMatch\n    // if (!matches) return null\n    if(!matches) {\n        if(!isAlive) return null\n        else return renderChild({ display: 'none' })\n    }\n\n    // beforeEnter | beforeUpdate guard\n    \n    globalCtx.prevPath = basePath\n\n    let isEnter = false\n    enum Execute_Guard_Type {\n        None,\n        Update,\n        // If not in exact mode. However should execute update instead enter\n        Update_UnResolve,\n        Enter,\n    }\n    let execute_guard_type = Execute_Guard_Type.None\n    // judge execute RouteGuard Type\n    // Type: Update | Enter \n    // emit UpdateGuard\n\n    if(updateParamsRef.current.timer > 1) {\n        // only emit UpdateGuard in unExact Mode \n        if(!exact) {\n            if(updateGuard) {\n                const next = () => isEnter = true\n                updateGuard(prevParams,updateParamsRef.current.prevParams,navigate,next)\n            } else isEnter = true\n            execute_guard_type = Execute_Guard_Type.Update\n        }\n        else execute_guard_type = Execute_Guard_Type.Update_UnResolve\n    }\n\n    if(execute_guard_type == Execute_Guard_Type.None) {\n        const from = '*'\n\n        const guardGroup = JSON.stringify({ from: from,to: basePath })\n        const executeGuards = globalCtx.guardMap[guardGroup]  \n \n        if(executeGuards) {\n            executeGuards(null,() => isEnter = true) \n        } else {\n            const matched = fuzzyMatchGuard(globalCtx,basePath)\n            if(matched[0]) {\n                const fuzzyExecuteGuard = globalCtx.guardMap[matched[0]]\n                fuzzyExecuteGuard(matched[1],() => isEnter = true)\n            }\n            else isEnter = true\n        }\n    }\n\n    if(!isEnter) return null\n    \n    return renderChild()\n\n    function renderChild(extraProps ?: object) {\n        // React-Router style `component` prop\n        if (component) return h(component, { params,...extraProps } as any)\n\n        // support render prop or plain children\n        return typeof children === \"function\" ? cloneElement(children(params),extraProps) : cloneElement(children as any,extraProps)\n    }\n}\n\nexport const useLeaveGuard = (props:RouterGuard) => {\n    const [curPath,navigate] = useLocationHook()\n    const { path = curPath,resolve,to,type } = props\n    // type : 'beforeLeave' | 'beforeEnter'\n    const globalRef = useContext(RouterCtx)\n    \n    useEffect(() => {  \n        let realPath = path\n\n        // call useGuard in FC \n        // first render is not effected\n        if(type == 'beforeEnter') realPath = '*'\n        const currentGuardFlagGroup = JSON.stringify({ from: realPath,to })\n        \n        globalRef.v.guardMap[currentGuardFlagGroup] = next => resolve(navigate,next)\n    },[path,resolve,to])\n}\n\nexport const connectGuard = (type:Exclude<guardTypes,'beforeUpdate'>,resolve,from:string,to?:string) => (Component:React.FC):React.FC => {\n    if(type === 'beforeEnter') {\n        to = '*'\n    }\n\n    return (props) => {\n        const { children,...others } = props\n        const matcher = useRouter().matcher\n        const globalRef = useContext(RouterCtx)\n        const { prevPath } = globalRef.v\n        const [curPath,navigate] = useLocationHook()\n\n        let isRender = 0\n        const next = () => {\n            isRender = 1\n        }\n\n        if(type === 'beforeEnter' ) {\n            if(from === '*' || matcher(from,prevPath)[0]) {\n                resolve(prevPath,navigate,next)\n            }\n        }\n\n        if(isRender) return h(Component,others,children)\n        return h('div')\n    }\n}\n\nexport const Link = props => {\n    const [, navigate] = useLocation()\n    const { base } = useRouter()\n\n    const href = props.href || props.to\n    const { children, onClick } = props\n\n    const handleClick = useCallback(\n        event => {\n            if (\n                event.ctrlKey ||\n                event.metaKey ||\n                event.altKey ||\n                event.shiftKey ||\n                event.button !== 0\n            )\n                return\n\n            event.preventDefault()\n            navigate(href)\n            onClick && onClick(event)\n        },\n        [href, onClick, navigate]\n    )\n\n    // default render 'a' component\n    const extraProps = { href: base + href, onClick: handleClick, to: null }\n    const jsx = isValidElement(children) ? children : h(\"a\", props)\n\n    return cloneElement(jsx, extraProps)\n}\n\nexport const Switch = ({ children, location }) => {\n    const { matcher } = useRouter()\n    const [originalLocation] = useLocation()\n\n    children = Array.isArray(children) ? children : [children]\n\n    for (const element of children) {\n        let match:[boolean,params]\n\n        if (\n            isValidElement(element) &&\n            \n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = element.props['path']\n          ? matcher(element.props['path'], location || originalLocation)\n          : [false, {}]\n      )[0]\n        )\n            return cloneElement(element, { match,path: element.props['path'] } as any)\n    }\n\n    // eslint-disable-next-line\n    console.warn(`\n        Switch component has no suitable render element;\n        please check path prop\n    `)\n    return null\n}\n\nexport const Redirect = props => {\n    const [, push] = useLocation()\n    useLayoutEffect(() => {\n        // layout has finished \n        // replace url to new \n        push(\"replace\" ,props.href || props.to)\n\n    // we pass an empty array of dependecies to ensure that\n    // we only run the effect once after initial render\n    }, []) \n\n    return null\n}\n\n\nexport const Lazy:React.FC<{loading:React.ReactNode,component:() => Promise<{default:React.ComponentType}>}> = ({ loading,component }) => {\n    const RC = lazy(component) \n    return h(Suspense,{ fallback: loading },h(RC))\n}\n    \n\nexport default useRoute","import { useRoute,useNestRoute } from './index'\n\nexport const getParams = (isExact:boolean,pattern:RegExp | string,...params: string[]) => {\n    const current_params = isExact ? useRoute(pattern)[0][1] : useNestRoute(pattern)[0][1]\n    const result = {}\n    for(let param of params) {\n        result[param] = current_params[param]\n    }\n    return result\n}","import { useLocation as useLocationHook,navigate,fuzzyMatchGuard }  from './useLocation'\nimport makeMatcher from \"./matcher\"\nimport { useActionEffect } from './tools'\n\nimport {\n    useRef,\n    useLayoutEffect,\n    useEffect,\n    useContext,\n    useCallback,\n    isValidElement,\n    cloneElement,\n    createElement as h,\n    Suspense,\n    lazy,\n} from \"react\"\n\nimport { RouterCtx,store,isMatch,params,matchFn } from './context'\nexport { getParams } from './helper'\n/*\n * Hooks API: useRouter, useRoute and useLocation\n */\n\ntype RouteProps = {\n    path:string,\n    match ?: matchFn\n    enterGuard ?: EnterRouteGuard,\n    updateGuard ?: UpdateRouteGuard,\n    component ?: React.FC | React.ComponentClass,\n    exact ?: boolean,\n    isAlive ?: boolean\n} \n\ntype updateGuardStruct = {\n    timer:number;\n    path:string;\n    prevParams:params;\n}\n\ntype guardTypes = 'beforeLeave' | 'beforeUpdate' | 'beforeEnter'\n\ninterface RouterGuard {\n    path ?: string,\n    to:string,\n    resolve:(navigate:navigate,next:Function) => void,\n    type:\"beforeLeave\" | \"beforeEnter\"\n} \n\ninterface EnterRouteGuard {\n    (params:any,navigate:navigate,next:Function) : void,\n}\n\ninterface UpdateRouteGuard {\n    (beforeParams:params,currentParams:params,navigate:Function,next:Function):void\n}\nconst buildRouter = ({\n    base = \"\",\n    matcher = makeMatcher() as any,\n    guardMap = {},\n    prevPath = \"\"\n}:store['v'] = {} as store['v']) => ({ base, matcher,guardMap,prevPath })\n\nexport const useRouter = () => {\n    const globalRef = useContext(RouterCtx)\n\n    // either obtain the router from the outer context (provided by the\n    // `<Router /> component) or create an implicit one on demand.\n    return globalRef.v || (globalRef.v = buildRouter())\n}\n\nexport const useLocation = () => {\n    const router = useRouter()\n    return useLocationHook(router)\n}\n\nexport const useRoute = (pattern:RegExp | string):[[isMatch,params],string,(type:\"replace\" | \"to\",url:string) => void] => {\n    const [path,navigate] = useLocation()\n    return [useRouter().matcher(pattern, path),path,navigate]\n}\n\nexport const useNestRoute = (pattern:RegExp | string,prevMatchObject?:updateGuardStruct):[[isMatch,params],string,(type:\"replace\" | \"to\",url:string) => void] => {\n    const [path,navigate] = useLocation()\n    const matcher = useRouter().matcher\n\n    const match_paths = path.split('/')\n    let useRouteMatch:[isMatch,params] = [false,{}]\n\n    // avoid '/' Component show in any router\n    for(let i = 1,base = \"/\";i < match_paths.length;i++) {\n        let curPath = base + match_paths[i]\n        const result = matcher(pattern,curPath)\n        if(result[0]) {\n            if(prevMatchObject) {\n                if(prevMatchObject!.path !== curPath) {\n                    prevMatchObject.path = curPath\n                    prevMatchObject.timer++\n                    prevMatchObject.prevParams = result[1]\n                }\n            } \n            useRouteMatch = result\n            break\n        }\n        base += match_paths[i] + '/'\n    }\n    useRouteMatch[0] || prevMatchObject && (prevMatchObject.timer = 0,prevMatchObject.prevParams = {})\n    return [useRouteMatch,path,navigate]\n}\n\n/*\n * Router API: Router, Route, Link, Switch\n */\n\nexport const Router = props => {\n    const ref = useRef<null | store>(null)\n\n    // only in first render to call buildRouter\n    const value = ref.current || (ref.current = { v: buildRouter(props) })\n\n    return h(RouterCtx.Provider, {\n        value: value,\n        children: props.children\n    })\n}\n\nexport const Route:React.FC<RouteProps> = ({ path, match, component, children, enterGuard,updateGuard,exact = false,isAlive }) => {\n    const updateParamsRef = useRef<updateGuardStruct>({ path: \"\",timer: 0,prevParams: {} })\n    const prevParams = updateParamsRef.current.prevParams\n    const [useRouteMatch,basePath,navigate] = !exact ? useNestRoute(path,updateParamsRef.current) : useRoute(path)\n    const globalCtx = useRouter()\n\n    useActionEffect(() => {\n        if(!enterGuard) return\n        let guardGroup = JSON.stringify({ from: '*',to: path })\n        globalCtx.guardMap[guardGroup] = (params,next) => enterGuard(params,navigate,next)\n    },[enterGuard])\n    // `props.match` is present - Route is controlled by the Switch\n    const [matches, params] = match && match(path,basePath) || useRouteMatch\n    // if (!matches) return null\n    if(!matches) {\n        if(!isAlive) return null\n        else return renderChild({ display: 'none' })\n    }\n\n    // beforeEnter | beforeUpdate guard\n    \n    globalCtx.prevPath = basePath\n\n    let isEnter = false\n    enum Execute_Guard_Type {\n        None,\n        Update,\n        // If not in exact mode. However should execute update instead enter\n        Update_UnResolve,\n        Enter,\n    }\n    let execute_guard_type = Execute_Guard_Type.None\n    // judge execute RouteGuard Type\n    // Type: Update | Enter \n    // emit UpdateGuard\n\n    if(updateParamsRef.current.timer > 1) {\n        // only emit UpdateGuard in unExact Mode \n        if(!exact) {\n            if(updateGuard) {\n                const next = () => isEnter = true\n                updateGuard(prevParams,updateParamsRef.current.prevParams,navigate,next)\n            } else isEnter = true\n            execute_guard_type = Execute_Guard_Type.Update\n        }\n        else execute_guard_type = Execute_Guard_Type.Update_UnResolve\n    }\n\n    if(execute_guard_type == Execute_Guard_Type.None) {\n        const from = '*'\n\n        const guardGroup = JSON.stringify({ from: from,to: basePath })\n        const executeGuards = globalCtx.guardMap[guardGroup]  \n \n        if(executeGuards) {\n            executeGuards(null,() => isEnter = true) \n        } else {\n            const matched = fuzzyMatchGuard(globalCtx,basePath)\n            if(matched[0]) {\n                const fuzzyExecuteGuard = globalCtx.guardMap[matched[0]]\n                fuzzyExecuteGuard(matched[1],() => isEnter = true)\n            }\n            else isEnter = true\n        }\n    }\n\n    if(!isEnter) return null\n    \n    return renderChild()\n\n    function renderChild(extraProps ?: object) {\n        // React-Router style `component` prop\n        if (component) return h(component, { params,...extraProps } as any)\n\n        // support render prop or plain children\n        return typeof children === \"function\" ? cloneElement(children(params),extraProps) : cloneElement(children as any,extraProps)\n    }\n}\n\nexport const useLeaveGuard = (props:RouterGuard) => {\n    const [curPath,navigate] = useLocationHook()\n    const { path = curPath,resolve,to,type } = props\n    // type : 'beforeLeave' | 'beforeEnter'\n    const globalRef = useContext(RouterCtx)\n    \n    useEffect(() => {  \n        let realPath = path\n\n        // call useGuard in FC \n        // first render is not effected\n        if(type == 'beforeEnter') realPath = '*'\n        const currentGuardFlagGroup = JSON.stringify({ from: realPath,to })\n        \n        globalRef.v.guardMap[currentGuardFlagGroup] = next => resolve(navigate,next)\n    },[path,resolve,to])\n}\n\nexport const connectGuard = (type:Exclude<guardTypes,'beforeUpdate'>,resolve,from:string,to?:string) => (Component:React.FC):React.FC => {\n    if(type === 'beforeEnter') {\n        to = '*'\n    }\n\n    return (props) => {\n        const { children,...others } = props\n        const matcher = useRouter().matcher\n        const globalRef = useContext(RouterCtx)\n        const { prevPath } = globalRef.v\n        const [curPath,navigate] = useLocationHook()\n\n        let isRender = 0\n        const next = () => {\n            isRender = 1\n        }\n\n        if(type === 'beforeEnter' ) {\n            if(from === '*' || matcher(from,prevPath)[0]) {\n                resolve(prevPath,navigate,next)\n            }\n        }\n\n        if(isRender) return h(Component,others,children)\n        return h('div')\n    }\n}\n\nexport const Link = props => {\n    const [, navigate] = useLocation()\n    const { base } = useRouter()\n\n    const href = props.href || props.to\n    const { children, onClick } = props\n\n    const handleClick = useCallback(\n        event => {\n            if (\n                event.ctrlKey ||\n                event.metaKey ||\n                event.altKey ||\n                event.shiftKey ||\n                event.button !== 0\n            )\n                return\n\n            event.preventDefault()\n            navigate(href)\n            onClick && onClick(event)\n        },\n        [href, onClick, navigate]\n    )\n\n    // default render 'a' component\n    const extraProps = { href: base + href, onClick: handleClick, to: null }\n    const jsx = isValidElement(children) ? children : h(\"a\", props)\n\n    return cloneElement(jsx, extraProps)\n}\n\nexport const Switch = ({ children, location }) => {\n    const { matcher } = useRouter()\n    const [originalLocation] = useLocation()\n\n    children = Array.isArray(children) ? children : [children]\n\n    for (const element of children) {\n        let match:[boolean,params]\n\n        if (\n            isValidElement(element) &&\n            \n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = element.props['path']\n          ? matcher(element.props['path'], location || originalLocation)\n          : [false, {}]\n      )[0]\n        )\n            return cloneElement(element, { match,path: element.props['path'] } as any)\n    }\n\n    // eslint-disable-next-line\n    console.warn(`\n        Switch component has no suitable render element;\n        please check path prop\n    `)\n    return null\n}\n\nexport const Redirect = props => {\n    const [, push] = useLocation()\n    useLayoutEffect(() => {\n        // layout has finished \n        // replace url to new \n        push(\"replace\" ,props.href || props.to)\n\n    // we pass an empty array of dependecies to ensure that\n    // we only run the effect once after initial render\n    }, []) \n\n    return null\n}\n\n\nexport const Lazy:React.FC<{loading:React.ReactNode,component:() => Promise<{default:React.ComponentType}>}> = ({ loading,component }) => {\n    const RC = lazy(component) \n    return h(Suspense,{ fallback: loading },h(RC))\n}\n    \n\nexport default useRoute"],"names":["createContext","useState","useRef","useContext","useEffect","useCallback","useLocation","useLocationHook","buildRouter","useRouter","useRoute","useNestRoute","h","cloneElement","isValidElement","useLayoutEffect","lazy","Suspense"],"mappings":"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"}